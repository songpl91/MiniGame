# è¡Œä¸ºæ ‘èŠ‚ç‚¹è®¾è®¡è§„èŒƒ

## ğŸ“‹ 1. èŠ‚ç‚¹åˆ†ç±»ä½“ç³»

### 1.1 æ§åˆ¶èŠ‚ç‚¹ (Control Nodes)

æ§åˆ¶èŠ‚ç‚¹è´Ÿè´£ç®¡ç†å­èŠ‚ç‚¹çš„æ‰§è¡Œæµç¨‹å’Œé€»è¾‘ã€‚

#### 1.1.1 åºåˆ—èŠ‚ç‚¹ (Sequence)
```csharp
/// <summary>
/// åºåˆ—èŠ‚ç‚¹ - æŒ‰é¡ºåºæ‰§è¡Œæ‰€æœ‰å­èŠ‚ç‚¹
/// åªæœ‰å½“æ‰€æœ‰å­èŠ‚ç‚¹éƒ½è¿”å›Successæ—¶æ‰è¿”å›Success
/// ä»»ä½•ä¸€ä¸ªå­èŠ‚ç‚¹è¿”å›Failureæ—¶ç«‹å³è¿”å›Failure
/// </summary>
public class SequenceNode : ControlNode
{
    private int currentChildIndex = 0;
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        while (currentChildIndex < Children.Count)
        {
            var child = Children[currentChildIndex];
            var status = child.Execute(context);
            
            switch (status)
            {
                case NodeStatus.Success:
                    currentChildIndex++;
                    continue;
                case NodeStatus.Failure:
                    Reset();
                    return NodeStatus.Failure;
                case NodeStatus.Running:
                    return NodeStatus.Running;
            }
        }
        
        Reset();
        return NodeStatus.Success;
    }
}
```

#### 1.1.2 é€‰æ‹©èŠ‚ç‚¹ (Selector)
```csharp
/// <summary>
/// é€‰æ‹©èŠ‚ç‚¹ - æŒ‰é¡ºåºå°è¯•æ‰§è¡Œå­èŠ‚ç‚¹
/// ä»»ä½•ä¸€ä¸ªå­èŠ‚ç‚¹è¿”å›Successæ—¶ç«‹å³è¿”å›Success
/// åªæœ‰å½“æ‰€æœ‰å­èŠ‚ç‚¹éƒ½è¿”å›Failureæ—¶æ‰è¿”å›Failure
/// </summary>
public class SelectorNode : ControlNode
{
    private int currentChildIndex = 0;
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        while (currentChildIndex < Children.Count)
        {
            var child = Children[currentChildIndex];
            var status = child.Execute(context);
            
            switch (status)
            {
                case NodeStatus.Success:
                    Reset();
                    return NodeStatus.Success;
                case NodeStatus.Failure:
                    currentChildIndex++;
                    continue;
                case NodeStatus.Running:
                    return NodeStatus.Running;
            }
        }
        
        Reset();
        return NodeStatus.Failure;
    }
}
```

#### 1.1.3 å¹¶è¡ŒèŠ‚ç‚¹ (Parallel)
```csharp
/// <summary>
/// å¹¶è¡ŒèŠ‚ç‚¹ - åŒæ—¶æ‰§è¡Œæ‰€æœ‰å­èŠ‚ç‚¹
/// æ ¹æ®æˆåŠŸ/å¤±è´¥ç­–ç•¥å†³å®šè¿”å›çŠ¶æ€
/// </summary>
public class ParallelNode : ControlNode
{
    [SerializeField] private ParallelPolicy successPolicy = ParallelPolicy.All;
    [SerializeField] private ParallelPolicy failurePolicy = ParallelPolicy.Any;
    
    private Dictionary<BehaviorTreeNode, NodeStatus> childStatuses;
    
    public enum ParallelPolicy
    {
        Any,    // ä»»æ„ä¸€ä¸ªæ»¡è¶³æ¡ä»¶
        All     // å…¨éƒ¨æ»¡è¶³æ¡ä»¶
    }
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        if (childStatuses == null)
        {
            childStatuses = new Dictionary<BehaviorTreeNode, NodeStatus>();
        }
        
        int successCount = 0;
        int failureCount = 0;
        int runningCount = 0;
        
        foreach (var child in Children)
        {
            if (!childStatuses.ContainsKey(child) || 
                childStatuses[child] == NodeStatus.Running)
            {
                var status = child.Execute(context);
                childStatuses[child] = status;
            }
            
            switch (childStatuses[child])
            {
                case NodeStatus.Success:
                    successCount++;
                    break;
                case NodeStatus.Failure:
                    failureCount++;
                    break;
                case NodeStatus.Running:
                    runningCount++;
                    break;
            }
        }
        
        // æ£€æŸ¥å¤±è´¥æ¡ä»¶
        if (failurePolicy == ParallelPolicy.Any && failureCount > 0)
        {
            Reset();
            return NodeStatus.Failure;
        }
        
        if (failurePolicy == ParallelPolicy.All && failureCount == Children.Count)
        {
            Reset();
            return NodeStatus.Failure;
        }
        
        // æ£€æŸ¥æˆåŠŸæ¡ä»¶
        if (successPolicy == ParallelPolicy.Any && successCount > 0)
        {
            Reset();
            return NodeStatus.Success;
        }
        
        if (successPolicy == ParallelPolicy.All && successCount == Children.Count)
        {
            Reset();
            return NodeStatus.Success;
        }
        
        return NodeStatus.Running;
    }
}
```

### 1.2 æ¡ä»¶èŠ‚ç‚¹ (Condition Nodes)

æ¡ä»¶èŠ‚ç‚¹ç”¨äºæ£€æŸ¥æ¸¸æˆçŠ¶æ€ã€ç©å®¶æ•°æ®ç­‰æ¡ä»¶ã€‚

#### 1.2.1 æ¸¸æˆçŠ¶æ€æ¡ä»¶
```csharp
/// <summary>
/// æ¸¸æˆçŠ¶æ€æ¡ä»¶èŠ‚ç‚¹
/// æ£€æŸ¥æŒ‡å®šçš„æ¸¸æˆçŠ¶æ€æ˜¯å¦æ»¡è¶³æ¡ä»¶
/// </summary>
public class GameStateConditionNode : ConditionNode
{
    [SerializeField] private string stateName;
    [SerializeField] private object expectedValue;
    [SerializeField] private ComparisonOperator comparisonOperator = ComparisonOperator.Equal;
    
    public enum ComparisonOperator
    {
        Equal,              // ç­‰äº
        NotEqual,           // ä¸ç­‰äº
        GreaterThan,        // å¤§äº
        GreaterThanOrEqual, // å¤§äºç­‰äº
        LessThan,           // å°äº
        LessThanOrEqual,    // å°äºç­‰äº
        Contains,           // åŒ…å«
        NotContains         // ä¸åŒ…å«
    }
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        var gameData = context.GameDataProvider;
        var currentValue = gameData.GetGameState(stateName);
        
        bool conditionMet = EvaluateCondition(currentValue, expectedValue, comparisonOperator);
        
        return conditionMet ? NodeStatus.Success : NodeStatus.Failure;
    }
    
    private bool EvaluateCondition(object current, object expected, ComparisonOperator op)
    {
        // å®ç°å„ç§æ¯”è¾ƒé€»è¾‘
        switch (op)
        {
            case ComparisonOperator.Equal:
                return Equals(current, expected);
            case ComparisonOperator.NotEqual:
                return !Equals(current, expected);
            // ... å…¶ä»–æ¯”è¾ƒæ“ä½œ
            default:
                return false;
        }
    }
}
```

#### 1.2.2 ç©å®¶æ•°æ®æ¡ä»¶
```csharp
/// <summary>
/// ç©å®¶æ•°æ®æ¡ä»¶èŠ‚ç‚¹
/// æ£€æŸ¥ç©å®¶çš„ç­‰çº§ã€é‡‘å¸ã€é“å…·ç­‰æ•°æ®
/// </summary>
public class PlayerDataConditionNode : ConditionNode
{
    [SerializeField] private PlayerDataType dataType;
    [SerializeField] private string dataKey;
    [SerializeField] private object expectedValue;
    [SerializeField] private ComparisonOperator comparisonOperator;
    
    public enum PlayerDataType
    {
        Level,          // ç­‰çº§
        Experience,     // ç»éªŒ
        Currency,       // è´§å¸
        Item,           // é“å…·
        Achievement,    // æˆå°±
        Custom          // è‡ªå®šä¹‰æ•°æ®
    }
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        var playerData = context.GameDataProvider.GetPlayerData();
        object currentValue = null;
        
        switch (dataType)
        {
            case PlayerDataType.Level:
                currentValue = playerData.Level;
                break;
            case PlayerDataType.Currency:
                currentValue = playerData.GetCurrency(dataKey);
                break;
            case PlayerDataType.Item:
                currentValue = playerData.GetItemCount(dataKey);
                break;
            // ... å…¶ä»–æ•°æ®ç±»å‹
        }
        
        bool conditionMet = EvaluateCondition(currentValue, expectedValue, comparisonOperator);
        return conditionMet ? NodeStatus.Success : NodeStatus.Failure;
    }
}
```

#### 1.2.3 UIçŠ¶æ€æ¡ä»¶
```csharp
/// <summary>
/// UIçŠ¶æ€æ¡ä»¶èŠ‚ç‚¹
/// æ£€æŸ¥UIå…ƒç´ çš„çŠ¶æ€ï¼ˆæ˜¯å¦æ˜¾ç¤ºã€æ˜¯å¦å¯äº¤äº’ç­‰ï¼‰
/// </summary>
public class UIStateConditionNode : ConditionNode
{
    [SerializeField] private string uiPath;
    [SerializeField] private UIStateType stateType;
    [SerializeField] private bool expectedState;
    
    public enum UIStateType
    {
        Visible,        // æ˜¯å¦å¯è§
        Active,         // æ˜¯å¦æ¿€æ´»
        Interactable,   // æ˜¯å¦å¯äº¤äº’
        Exists          // æ˜¯å¦å­˜åœ¨
    }
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        var uiElement = FindUIElement(uiPath);
        if (uiElement == null)
        {
            return stateType == UIStateType.Exists && !expectedState ? 
                NodeStatus.Success : NodeStatus.Failure;
        }
        
        bool currentState = false;
        switch (stateType)
        {
            case UIStateType.Visible:
                currentState = uiElement.gameObject.activeInHierarchy;
                break;
            case UIStateType.Active:
                currentState = uiElement.gameObject.activeSelf;
                break;
            case UIStateType.Interactable:
                var selectable = uiElement.GetComponent<Selectable>();
                currentState = selectable != null && selectable.interactable;
                break;
            case UIStateType.Exists:
                currentState = true;
                break;
        }
        
        return currentState == expectedState ? NodeStatus.Success : NodeStatus.Failure;
    }
}
```

### 1.3 åŠ¨ä½œèŠ‚ç‚¹ (Action Nodes)

åŠ¨ä½œèŠ‚ç‚¹æ‰§è¡Œå…·ä½“çš„å¼•å¯¼æ“ä½œã€‚

#### 1.3.1 æ˜¾ç¤ºæ¶ˆæ¯åŠ¨ä½œ
```csharp
/// <summary>
/// æ˜¾ç¤ºæ¶ˆæ¯åŠ¨ä½œèŠ‚ç‚¹
/// åœ¨å±å¹•ä¸Šæ˜¾ç¤ºå¼•å¯¼æ¶ˆæ¯
/// </summary>
public class ShowMessageActionNode : ActionNode
{
    [SerializeField] private string message;
    [SerializeField] private string localizationKey;
    [SerializeField] private float duration = 3f;
    [SerializeField] private MessagePosition position = MessagePosition.Center;
    [SerializeField] private MessageStyle style = MessageStyle.Bubble;
    [SerializeField] private bool waitForConfirm = false;
    
    public enum MessagePosition
    {
        Top, Center, Bottom, Custom
    }
    
    public enum MessageStyle
    {
        Bubble, Toast, Dialog, Overlay
    }
    
    private bool isShowing = false;
    private float showStartTime;
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        if (!isShowing)
        {
            StartShowMessage(context);
            isShowing = true;
            showStartTime = Time.time;
        }
        
        // æ£€æŸ¥æ˜¯å¦å®Œæˆ
        if (waitForConfirm)
        {
            return CheckUserConfirmation() ? NodeStatus.Success : NodeStatus.Running;
        }
        else
        {
            return Time.time - showStartTime >= duration ? NodeStatus.Success : NodeStatus.Running;
        }
    }
    
    private void StartShowMessage(TreeExecutionContext context)
    {
        var displayText = GetLocalizedMessage(context);
        var messageUI = context.UIManager.GetMessageUI();
        
        messageUI.ShowMessage(displayText, position, style, duration);
        
        // è®°å½•åˆ†ææ•°æ®
        context.Analytics.TrackEvent("tutorial_message_shown", new Dictionary<string, object>
        {
            ["message_key"] = localizationKey,
            ["position"] = position.ToString(),
            ["style"] = style.ToString()
        });
    }
    
    private string GetLocalizedMessage(TreeExecutionContext context)
    {
        if (!string.IsNullOrEmpty(localizationKey))
        {
            return context.LocalizationManager.GetText(localizationKey);
        }
        return message;
    }
}
```

#### 1.3.2 é«˜äº®UIåŠ¨ä½œ
```csharp
/// <summary>
/// é«˜äº®UIåŠ¨ä½œèŠ‚ç‚¹
/// é«˜äº®æ˜¾ç¤ºæŒ‡å®šçš„UIå…ƒç´ 
/// </summary>
public class HighlightUIActionNode : ActionNode
{
    [SerializeField] private string targetPath;
    [SerializeField] private string targetTag;
    [SerializeField] private HighlightType highlightType = HighlightType.Glow;
    [SerializeField] private Color highlightColor = Color.yellow;
    [SerializeField] private AnimationType animationType = AnimationType.Pulse;
    [SerializeField] private float intensity = 1f;
    [SerializeField] private float duration = -1f; // -1è¡¨ç¤ºæŒç»­åˆ°æ‰‹åŠ¨åœæ­¢
    
    public enum HighlightType
    {
        Glow,           // å‘å…‰æ•ˆæœ
        Outline,        // è½®å»“çº¿
        Mask,           // é®ç½©é«˜äº®
        Arrow,          // ç®­å¤´æŒ‡å‘
        Frame           // è¾¹æ¡†é«˜äº®
    }
    
    public enum AnimationType
    {
        None,           // æ— åŠ¨ç”»
        Pulse,          // è„‰å†²
        Blink,          // é—ªçƒ
        Shake,          // éœ‡åŠ¨
        Scale,          // ç¼©æ”¾
        Rotate          // æ—‹è½¬
    }
    
    private GameObject highlightTarget;
    private HighlightEffect highlightEffect;
    private bool isHighlighting = false;
    private float highlightStartTime;
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        if (!isHighlighting)
        {
            StartHighlight(context);
            isHighlighting = true;
            highlightStartTime = Time.time;
        }
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦åœæ­¢é«˜äº®
        if (duration > 0 && Time.time - highlightStartTime >= duration)
        {
            StopHighlight();
            return NodeStatus.Success;
        }
        
        return duration > 0 ? NodeStatus.Running : NodeStatus.Success;
    }
    
    private void StartHighlight(TreeExecutionContext context)
    {
        highlightTarget = FindTargetUI(targetPath, targetTag);
        if (highlightTarget == null)
        {
            Debug.LogWarning($"æ‰¾ä¸åˆ°é«˜äº®ç›®æ ‡: {targetPath}");
            return;
        }
        
        highlightEffect = CreateHighlightEffect(highlightTarget);
        highlightEffect.StartHighlight(highlightType, highlightColor, animationType, intensity);
        
        // è®°å½•åˆ†ææ•°æ®
        context.Analytics.TrackEvent("tutorial_highlight_started", new Dictionary<string, object>
        {
            ["target_path"] = targetPath,
            ["highlight_type"] = highlightType.ToString(),
            ["animation_type"] = animationType.ToString()
        });
    }
    
    private void StopHighlight()
    {
        if (highlightEffect != null)
        {
            highlightEffect.StopHighlight();
            highlightEffect = null;
        }
        isHighlighting = false;
    }
}
```

#### 1.3.3 ç­‰å¾…ç‚¹å‡»åŠ¨ä½œ
```csharp
/// <summary>
/// ç­‰å¾…ç‚¹å‡»åŠ¨ä½œèŠ‚ç‚¹
/// ç­‰å¾…ç”¨æˆ·ç‚¹å‡»æŒ‡å®šçš„UIå…ƒç´ 
/// </summary>
public class WaitForClickActionNode : ActionNode
{
    [SerializeField] private string targetPath;
    [SerializeField] private string targetTag;
    [SerializeField] private float timeout = 30f;
    [SerializeField] private bool allowSkip = true;
    [SerializeField] private string skipButtonText = "è·³è¿‡";
    [SerializeField] private bool autoHighlight = true;
    
    private GameObject clickTarget;
    private Button targetButton;
    private bool isWaiting = false;
    private bool clickReceived = false;
    private float waitStartTime;
    private HighlightEffect autoHighlightEffect;
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        if (!isWaiting)
        {
            StartWaiting(context);
            isWaiting = true;
            waitStartTime = Time.time;
        }
        
        // æ£€æŸ¥æ˜¯å¦æ”¶åˆ°ç‚¹å‡»
        if (clickReceived)
        {
            StopWaiting();
            return NodeStatus.Success;
        }
        
        // æ£€æŸ¥è¶…æ—¶
        if (timeout > 0 && Time.time - waitStartTime >= timeout)
        {
            StopWaiting();
            return NodeStatus.Failure;
        }
        
        return NodeStatus.Running;
    }
    
    private void StartWaiting(TreeExecutionContext context)
    {
        clickTarget = FindTargetUI(targetPath, targetTag);
        if (clickTarget == null)
        {
            Debug.LogWarning($"æ‰¾ä¸åˆ°ç‚¹å‡»ç›®æ ‡: {targetPath}");
            return;
        }
        
        targetButton = clickTarget.GetComponent<Button>();
        if (targetButton != null)
        {
            targetButton.onClick.AddListener(OnTargetClicked);
        }
        else
        {
            // æ·»åŠ é€šç”¨ç‚¹å‡»æ£€æµ‹
            var clickDetector = clickTarget.GetComponent<ClickDetector>();
            if (clickDetector == null)
            {
                clickDetector = clickTarget.AddComponent<ClickDetector>();
            }
            clickDetector.OnClicked += OnTargetClicked;
        }
        
        // è‡ªåŠ¨é«˜äº®
        if (autoHighlight)
        {
            autoHighlightEffect = CreateHighlightEffect(clickTarget);
            autoHighlightEffect.StartHighlight(HighlightType.Glow, Color.yellow, AnimationType.Pulse, 1f);
        }
        
        // æ˜¾ç¤ºè·³è¿‡æŒ‰é’®
        if (allowSkip)
        {
            context.UIManager.ShowSkipButton(skipButtonText, OnSkipClicked);
        }
        
        // è®°å½•åˆ†ææ•°æ®
        context.Analytics.TrackEvent("tutorial_wait_click_started", new Dictionary<string, object>
        {
            ["target_path"] = targetPath,
            ["timeout"] = timeout,
            ["allow_skip"] = allowSkip
        });
    }
    
    private void OnTargetClicked()
    {
        clickReceived = true;
        
        // è®°å½•ç”¨æˆ·è¡Œä¸º
        var context = GetCurrentContext();
        context.Analytics.TrackEvent("tutorial_target_clicked", new Dictionary<string, object>
        {
            ["target_path"] = targetPath,
            ["wait_time"] = Time.time - waitStartTime
        });
    }
    
    private void OnSkipClicked()
    {
        clickReceived = true;
        
        // è®°å½•è·³è¿‡è¡Œä¸º
        var context = GetCurrentContext();
        context.Analytics.TrackEvent("tutorial_step_skipped", new Dictionary<string, object>
        {
            ["target_path"] = targetPath,
            ["wait_time"] = Time.time - waitStartTime
        });
    }
    
    private void StopWaiting()
    {
        if (targetButton != null)
        {
            targetButton.onClick.RemoveListener(OnTargetClicked);
        }
        
        if (autoHighlightEffect != null)
        {
            autoHighlightEffect.StopHighlight();
            autoHighlightEffect = null;
        }
        
        var context = GetCurrentContext();
        context.UIManager.HideSkipButton();
        
        isWaiting = false;
        clickReceived = false;
    }
}
```

### 1.4 è£…é¥°èŠ‚ç‚¹ (Decorator Nodes)

è£…é¥°èŠ‚ç‚¹ä¿®æ”¹å­èŠ‚ç‚¹çš„è¡Œä¸ºã€‚

#### 1.4.1 é‡å¤è£…é¥°å™¨
```csharp
/// <summary>
/// é‡å¤è£…é¥°å™¨èŠ‚ç‚¹
/// é‡å¤æ‰§è¡Œå­èŠ‚ç‚¹æŒ‡å®šæ¬¡æ•°æˆ–ç›´åˆ°æ»¡è¶³æ¡ä»¶
/// </summary>
public class RepeatDecoratorNode : DecoratorNode
{
    [SerializeField] private RepeatType repeatType = RepeatType.Count;
    [SerializeField] private int repeatCount = 1;
    [SerializeField] private float repeatInterval = 0f;
    [SerializeField] private bool resetChildOnRepeat = true;
    
    public enum RepeatType
    {
        Count,          // é‡å¤æŒ‡å®šæ¬¡æ•°
        UntilSuccess,   // é‡å¤ç›´åˆ°æˆåŠŸ
        UntilFailure,   // é‡å¤ç›´åˆ°å¤±è´¥
        Forever         // æ°¸è¿œé‡å¤
    }
    
    private int currentRepeatCount = 0;
    private float lastExecutionTime = 0f;
    private NodeStatus lastChildStatus = NodeStatus.Running;
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        // æ£€æŸ¥é‡å¤é—´éš”
        if (repeatInterval > 0 && Time.time - lastExecutionTime < repeatInterval)
        {
            return NodeStatus.Running;
        }
        
        // æ‰§è¡Œå­èŠ‚ç‚¹
        if (Child != null)
        {
            var childStatus = Child.Execute(context);
            
            // å­èŠ‚ç‚¹è¿˜åœ¨è¿è¡Œä¸­
            if (childStatus == NodeStatus.Running)
            {
                return NodeStatus.Running;
            }
            
            lastChildStatus = childStatus;
            lastExecutionTime = Time.time;
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦ç»§ç»­é‡å¤
            if (ShouldContinueRepeat(childStatus))
            {
                currentRepeatCount++;
                
                if (resetChildOnRepeat)
                {
                    Child.OnReset();
                }
                
                return NodeStatus.Running;
            }
            else
            {
                Reset();
                return childStatus;
            }
        }
        
        return NodeStatus.Failure;
    }
    
    private bool ShouldContinueRepeat(NodeStatus childStatus)
    {
        switch (repeatType)
        {
            case RepeatType.Count:
                return currentRepeatCount < repeatCount;
            case RepeatType.UntilSuccess:
                return childStatus != NodeStatus.Success;
            case RepeatType.UntilFailure:
                return childStatus != NodeStatus.Failure;
            case RepeatType.Forever:
                return true;
            default:
                return false;
        }
    }
    
    public override void OnReset()
    {
        base.OnReset();
        currentRepeatCount = 0;
        lastExecutionTime = 0f;
        lastChildStatus = NodeStatus.Running;
    }
}
```

#### 1.4.2 å»¶è¿Ÿè£…é¥°å™¨
```csharp
/// <summary>
/// å»¶è¿Ÿè£…é¥°å™¨èŠ‚ç‚¹
/// å»¶è¿ŸæŒ‡å®šæ—¶é—´åæ‰§è¡Œå­èŠ‚ç‚¹
/// </summary>
public class DelayDecoratorNode : DecoratorNode
{
    [SerializeField] private float delayTime = 1f;
    [SerializeField] private bool randomDelay = false;
    [SerializeField] private float minDelay = 0.5f;
    [SerializeField] private float maxDelay = 2f;
    
    private bool isDelaying = false;
    private float delayStartTime;
    private float actualDelayTime;
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        if (!isDelaying)
        {
            StartDelay();
            isDelaying = true;
            delayStartTime = Time.time;
        }
        
        // æ£€æŸ¥å»¶è¿Ÿæ˜¯å¦ç»“æŸ
        if (Time.time - delayStartTime >= actualDelayTime)
        {
            // å»¶è¿Ÿç»“æŸï¼Œæ‰§è¡Œå­èŠ‚ç‚¹
            if (Child != null)
            {
                var childStatus = Child.Execute(context);
                
                if (childStatus != NodeStatus.Running)
                {
                    Reset();
                }
                
                return childStatus;
            }
            else
            {
                Reset();
                return NodeStatus.Success;
            }
        }
        
        return NodeStatus.Running;
    }
    
    private void StartDelay()
    {
        if (randomDelay)
        {
            actualDelayTime = UnityEngine.Random.Range(minDelay, maxDelay);
        }
        else
        {
            actualDelayTime = delayTime;
        }
    }
    
    public override void OnReset()
    {
        base.OnReset();
        isDelaying = false;
        delayStartTime = 0f;
        actualDelayTime = 0f;
    }
}
```

#### 1.4.3 æ¡ä»¶è£…é¥°å™¨
```csharp
/// <summary>
/// æ¡ä»¶è£…é¥°å™¨èŠ‚ç‚¹
/// åªæœ‰å½“æ¡ä»¶æ»¡è¶³æ—¶æ‰æ‰§è¡Œå­èŠ‚ç‚¹
/// </summary>
public class ConditionalDecoratorNode : DecoratorNode
{
    [SerializeField] private string conditionKey;
    [SerializeField] private object expectedValue;
    [SerializeField] private ComparisonOperator comparisonOperator = ComparisonOperator.Equal;
    [SerializeField] private bool checkEveryTick = false;
    
    private bool conditionChecked = false;
    private bool conditionMet = false;
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        // æ£€æŸ¥æ¡ä»¶
        if (!conditionChecked || checkEveryTick)
        {
            conditionMet = CheckCondition(context);
            conditionChecked = true;
        }
        
        if (!conditionMet)
        {
            return NodeStatus.Failure;
        }
        
        // æ¡ä»¶æ»¡è¶³ï¼Œæ‰§è¡Œå­èŠ‚ç‚¹
        if (Child != null)
        {
            var childStatus = Child.Execute(context);
            
            if (childStatus != NodeStatus.Running)
            {
                Reset();
            }
            
            return childStatus;
        }
        
        return NodeStatus.Success;
    }
    
    private bool CheckCondition(TreeExecutionContext context)
    {
        var blackboard = context.Blackboard;
        var currentValue = blackboard.GetValue<object>(conditionKey);
        
        return EvaluateCondition(currentValue, expectedValue, comparisonOperator);
    }
    
    public override void OnReset()
    {
        base.OnReset();
        conditionChecked = false;
        conditionMet = false;
    }
}
```

## ğŸ”§ 2. èŠ‚ç‚¹å‚æ•°é…ç½®ç³»ç»Ÿ

### 2.1 å‚æ•°å®šä¹‰æ¡†æ¶

```csharp
/// <summary>
/// èŠ‚ç‚¹å‚æ•°å®šä¹‰
/// å®šä¹‰èŠ‚ç‚¹å¯é…ç½®çš„å‚æ•°
/// </summary>
[System.Serializable]
public class ParameterDefinition
{
    public string name;                 // å‚æ•°åç§°
    public string displayName;          // æ˜¾ç¤ºåç§°
    public ParameterType type;          // å‚æ•°ç±»å‹
    public object defaultValue;         // é»˜è®¤å€¼
    public bool required;               // æ˜¯å¦å¿…éœ€
    public string description;          // å‚æ•°æè¿°
    public ParameterConstraint constraint; // å‚æ•°çº¦æŸ
    
    public enum ParameterType
    {
        String,
        Int,
        Float,
        Bool,
        Vector2,
        Vector3,
        Color,
        Enum,
        Object,
        Array,
        Custom
    }
}

/// <summary>
/// å‚æ•°çº¦æŸ
/// </summary>
[System.Serializable]
public class ParameterConstraint
{
    public object minValue;             // æœ€å°å€¼
    public object maxValue;             // æœ€å¤§å€¼
    public string[] allowedValues;      // å…è®¸çš„å€¼åˆ—è¡¨
    public string validationRegex;      // éªŒè¯æ­£åˆ™è¡¨è¾¾å¼
    public string validationMessage;    // éªŒè¯å¤±è´¥æ¶ˆæ¯
}
```

### 2.2 å‚æ•°éªŒè¯ç³»ç»Ÿ

```csharp
/// <summary>
/// å‚æ•°éªŒè¯å™¨
/// éªŒè¯èŠ‚ç‚¹å‚æ•°çš„æœ‰æ•ˆæ€§
/// </summary>
public class ParameterValidator
{
    /// <summary>
    /// éªŒè¯ç»“æœ
    /// </summary>
    public class ValidationResult
    {
        public bool IsValid { get; set; }
        public List<string> Errors { get; set; } = new List<string>();
        public List<string> Warnings { get; set; } = new List<string>();
        
        public static ValidationResult Success => new ValidationResult { IsValid = true };
        
        public static ValidationResult Failure(string error)
        {
            return new ValidationResult 
            { 
                IsValid = false, 
                Errors = new List<string> { error } 
            };
        }
    }
    
    /// <summary>
    /// éªŒè¯èŠ‚ç‚¹å‚æ•°
    /// </summary>
    public ValidationResult ValidateParameters(BehaviorTreeNode node, NodeConfig config)
    {
        var result = new ValidationResult { IsValid = true };
        var definitions = node.GetParameterDefinitions();
        
        foreach (var definition in definitions)
        {
            var paramResult = ValidateParameter(definition, config.GetParameter(definition.name));
            
            if (!paramResult.IsValid)
            {
                result.IsValid = false;
                result.Errors.AddRange(paramResult.Errors);
            }
            
            result.Warnings.AddRange(paramResult.Warnings);
        }
        
        return result;
    }
    
    private ValidationResult ValidateParameter(ParameterDefinition definition, object value)
    {
        var result = new ValidationResult { IsValid = true };
        
        // æ£€æŸ¥å¿…éœ€å‚æ•°
        if (definition.required && (value == null || value.Equals(GetDefaultValue(definition.type))))
        {
            return ValidationResult.Failure($"å‚æ•° '{definition.displayName}' æ˜¯å¿…éœ€çš„");
        }
        
        if (value == null)
        {
            return result;
        }
        
        // ç±»å‹æ£€æŸ¥
        if (!IsValidType(value, definition.type))
        {
            return ValidationResult.Failure($"å‚æ•° '{definition.displayName}' ç±»å‹ä¸åŒ¹é…");
        }
        
        // çº¦æŸæ£€æŸ¥
        if (definition.constraint != null)
        {
            var constraintResult = ValidateConstraint(value, definition.constraint);
            if (!constraintResult.IsValid)
            {
                return constraintResult;
            }
        }
        
        return result;
    }
}
```

## ğŸ¨ 3. èŠ‚ç‚¹å¯è§†åŒ–è®¾è®¡

### 3.1 èŠ‚ç‚¹å¤–è§‚é…ç½®

```csharp
/// <summary>
/// èŠ‚ç‚¹è§†è§‰é…ç½®
/// å®šä¹‰èŠ‚ç‚¹åœ¨ç¼–è¾‘å™¨ä¸­çš„å¤–è§‚
/// </summary>
[System.Serializable]
public class NodeVisualConfig
{
    [Header("åŸºæœ¬å¤–è§‚")]
    public Color nodeColor = Color.white;
    public string iconPath = "";
    public Vector2 nodeSize = new Vector2(150, 100);
    
    [Header("æ–‡æœ¬æ˜¾ç¤º")]
    public string displayName = "";
    public string description = "";
    public Color textColor = Color.black;
    public int fontSize = 12;
    
    [Header("è¿æ¥ç‚¹")]
    public bool hasInputPort = true;
    public bool hasOutputPort = true;
    public int maxInputConnections = 1;
    public int maxOutputConnections = -1; // -1è¡¨ç¤ºæ— é™åˆ¶
    
    [Header("åŠ¨ç”»æ•ˆæœ")]
    public bool enableHoverEffect = true;
    public bool enableSelectionEffect = true;
    public AnimationCurve scaleAnimation = AnimationCurve.EaseInOut(0, 1, 1, 1.1f);
}
```

### 3.2 èŠ‚ç‚¹çŠ¶æ€å¯è§†åŒ–

```csharp
/// <summary>
/// èŠ‚ç‚¹çŠ¶æ€å¯è§†åŒ–
/// åœ¨ç¼–è¾‘å™¨ä¸­æ˜¾ç¤ºèŠ‚ç‚¹çš„è¿è¡ŒçŠ¶æ€
/// </summary>
public class NodeStatusVisualizer
{
    private Dictionary<NodeStatus, NodeStatusStyle> statusStyles;
    
    [System.Serializable]
    public class NodeStatusStyle
    {
        public Color borderColor;
        public Color backgroundColor;
        public float borderWidth;
        public bool enablePulse;
        public float pulseSpeed;
        public string statusIcon;
    }
    
    public void InitializeStyles()
    {
        statusStyles = new Dictionary<NodeStatus, NodeStatusStyle>
        {
            [NodeStatus.Success] = new NodeStatusStyle
            {
                borderColor = Color.green,
                backgroundColor = new Color(0, 1, 0, 0.2f),
                borderWidth = 3f,
                enablePulse = false,
                statusIcon = "âœ“"
            },
            [NodeStatus.Failure] = new NodeStatusStyle
            {
                borderColor = Color.red,
                backgroundColor = new Color(1, 0, 0, 0.2f),
                borderWidth = 3f,
                enablePulse = false,
                statusIcon = "âœ—"
            },
            [NodeStatus.Running] = new NodeStatusStyle
            {
                borderColor = Color.yellow,
                backgroundColor = new Color(1, 1, 0, 0.2f),
                borderWidth = 2f,
                enablePulse = true,
                pulseSpeed = 2f,
                statusIcon = "â–¶"
            }
        };
    }
    
    public void UpdateNodeVisual(NodeView nodeView, NodeStatus status)
    {
        if (statusStyles.TryGetValue(status, out var style))
        {
            nodeView.SetBorderColor(style.borderColor);
            nodeView.SetBackgroundColor(style.backgroundColor);
            nodeView.SetBorderWidth(style.borderWidth);
            nodeView.SetStatusIcon(style.statusIcon);
            
            if (style.enablePulse)
            {
                nodeView.StartPulseAnimation(style.pulseSpeed);
            }
            else
            {
                nodeView.StopPulseAnimation();
            }
        }
    }
}
```

## ğŸ“Š 4. èŠ‚ç‚¹æ€§èƒ½ä¼˜åŒ–

### 4.1 èŠ‚ç‚¹å¯¹è±¡æ± 

```csharp
/// <summary>
/// èŠ‚ç‚¹å¯¹è±¡æ± 
/// ç®¡ç†èŠ‚ç‚¹å®ä¾‹çš„åˆ›å»ºå’Œå›æ”¶
/// </summary>
public class NodeObjectPool
{
    private Dictionary<System.Type, Queue<BehaviorTreeNode>> pools;
    private Dictionary<System.Type, int> poolSizes;
    private int defaultPoolSize = 10;
    private int maxPoolSize = 100;
    
    public T GetNode<T>() where T : BehaviorTreeNode, new()
    {
        var type = typeof(T);
        
        if (!pools.ContainsKey(type))
        {
            pools[type] = new Queue<BehaviorTreeNode>();
            poolSizes[type] = 0;
        }
        
        var pool = pools[type];
        
        if (pool.Count > 0)
        {
            var node = pool.Dequeue() as T;
            node.OnReset();
            return node;
        }
        else
        {
            return new T();
        }
    }
    
    public void ReturnNode<T>(T node) where T : BehaviorTreeNode
    {
        if (node == null) return;
        
        var type = typeof(T);
        
        if (!pools.ContainsKey(type))
        {
            pools[type] = new Queue<BehaviorTreeNode>();
            poolSizes[type] = 0;
        }
        
        var pool = pools[type];
        
        if (pool.Count < maxPoolSize)
        {
            node.OnReset();
            pool.Enqueue(node);
        }
    }
    
    public void PrewarmPool<T>(int count) where T : BehaviorTreeNode, new()
    {
        for (int i = 0; i < count; i++)
        {
            var node = new T();
            ReturnNode(node);
        }
    }
}
```

### 4.2 èŠ‚ç‚¹æ‰§è¡Œä¼˜åŒ–

```csharp
/// <summary>
/// èŠ‚ç‚¹æ‰§è¡Œä¼˜åŒ–å™¨
/// ä¼˜åŒ–èŠ‚ç‚¹çš„æ‰§è¡Œæ€§èƒ½
/// </summary>
public class NodeExecutionOptimizer
{
    private Dictionary<string, float> nodeExecutionTimes;
    private Dictionary<string, int> nodeExecutionCounts;
    private float performanceThreshold = 16.67f; // 60FPSé˜ˆå€¼
    
    /// <summary>
    /// ç›‘æ§èŠ‚ç‚¹æ‰§è¡Œæ€§èƒ½
    /// </summary>
    public void MonitorNodeExecution(BehaviorTreeNode node, System.Action nodeExecution)
    {
        var startTime = Time.realtimeSinceStartup;
        
        nodeExecution.Invoke();
        
        var executionTime = (Time.realtimeSinceStartup - startTime) * 1000f; // è½¬æ¢ä¸ºæ¯«ç§’
        
        RecordExecutionTime(node.NodeId, executionTime);
        
        if (executionTime > performanceThreshold)
        {
            Debug.LogWarning($"èŠ‚ç‚¹ {node.NodeId} æ‰§è¡Œæ—¶é—´è¿‡é•¿: {executionTime:F2}ms");
        }
    }
    
    private void RecordExecutionTime(string nodeId, float executionTime)
    {
        if (!nodeExecutionTimes.ContainsKey(nodeId))
        {
            nodeExecutionTimes[nodeId] = 0f;
            nodeExecutionCounts[nodeId] = 0;
        }
        
        nodeExecutionTimes[nodeId] += executionTime;
        nodeExecutionCounts[nodeId]++;
    }
    
    /// <summary>
    /// è·å–èŠ‚ç‚¹å¹³å‡æ‰§è¡Œæ—¶é—´
    /// </summary>
    public float GetAverageExecutionTime(string nodeId)
    {
        if (nodeExecutionTimes.ContainsKey(nodeId) && nodeExecutionCounts[nodeId] > 0)
        {
            return nodeExecutionTimes[nodeId] / nodeExecutionCounts[nodeId];
        }
        return 0f;
    }
    
    /// <summary>
    /// ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
    /// </summary>
    public PerformanceReport GeneratePerformanceReport()
    {
        var report = new PerformanceReport();
        
        foreach (var kvp in nodeExecutionTimes)
        {
            var nodeId = kvp.Key;
            var totalTime = kvp.Value;
            var count = nodeExecutionCounts[nodeId];
            var averageTime = totalTime / count;
            
            report.NodePerformances.Add(new NodePerformanceData
            {
                NodeId = nodeId,
                TotalExecutionTime = totalTime,
                ExecutionCount = count,
                AverageExecutionTime = averageTime,
                IsPerformanceCritical = averageTime > performanceThreshold
            });
        }
        
        return report;
    }
}

/// <summary>
/// æ€§èƒ½æŠ¥å‘Š
/// </summary>
public class PerformanceReport
{
    public List<NodePerformanceData> NodePerformances { get; set; } = new List<NodePerformanceData>();
    public float TotalExecutionTime => NodePerformances.Sum(p => p.TotalExecutionTime);
    public int TotalExecutionCount => NodePerformances.Sum(p => p.ExecutionCount);
    public float AverageExecutionTime => TotalExecutionTime / TotalExecutionCount;
}

/// <summary>
/// èŠ‚ç‚¹æ€§èƒ½æ•°æ®
/// </summary>
public class NodePerformanceData
{
    public string NodeId { get; set; }
    public float TotalExecutionTime { get; set; }
    public int ExecutionCount { get; set; }
    public float AverageExecutionTime { get; set; }
    public bool IsPerformanceCritical { get; set; }
}
```

## ğŸ” 5. èŠ‚ç‚¹è°ƒè¯•æ”¯æŒ

### 5.1 è°ƒè¯•ä¿¡æ¯æ”¶é›†

```csharp
/// <summary>
/// èŠ‚ç‚¹è°ƒè¯•ä¿¡æ¯æ”¶é›†å™¨
/// æ”¶é›†èŠ‚ç‚¹æ‰§è¡Œè¿‡ç¨‹ä¸­çš„è°ƒè¯•ä¿¡æ¯
/// </summary>
public class NodeDebugInfoCollector
{
    private Dictionary<string, List<NodeExecutionInfo>> executionHistory;
    private int maxHistorySize = 1000;
    
    /// <summary>
    /// èŠ‚ç‚¹æ‰§è¡Œä¿¡æ¯
    /// </summary>
    public class NodeExecutionInfo
    {
        public string nodeId;
        public string nodeType;
        public float timestamp;
        public NodeStatus inputStatus;
        public NodeStatus outputStatus;
        public float executionTime;
        public Dictionary<string, object> parameters;
        public Dictionary<string, object> blackboardSnapshot;
        public string errorMessage;
        public StackTrace stackTrace;
    }
    
    /// <summary>
    /// è®°å½•èŠ‚ç‚¹æ‰§è¡Œä¿¡æ¯
    /// </summary>
    public void RecordExecution(BehaviorTreeNode node, NodeStatus inputStatus, 
        NodeStatus outputStatus, float executionTime, TreeExecutionContext context)
    {
        var info = new NodeExecutionInfo
        {
            nodeId = node.NodeId,
            nodeType = node.GetType().Name,
            timestamp = Time.time,
            inputStatus = inputStatus,
            outputStatus = outputStatus,
            executionTime = executionTime,
            parameters = GetNodeParameters(node),
            blackboardSnapshot = GetBlackboardSnapshot(context.Blackboard)
        };
        
        if (!executionHistory.ContainsKey(node.NodeId))
        {
            executionHistory[node.NodeId] = new List<NodeExecutionInfo>();
        }
        
        var history = executionHistory[node.NodeId];
        history.Add(info);
        
        // é™åˆ¶å†å²è®°å½•å¤§å°
        if (history.Count > maxHistorySize)
        {
            history.RemoveAt(0);
        }
    }
    
    /// <summary>
    /// è®°å½•èŠ‚ç‚¹é”™è¯¯
    /// </summary>
    public void RecordError(BehaviorTreeNode node, string errorMessage, System.Exception exception = null)
    {
        var info = new NodeExecutionInfo
        {
            nodeId = node.NodeId,
            nodeType = node.GetType().Name,
            timestamp = Time.time,
            errorMessage = errorMessage,
            stackTrace = exception != null ? new StackTrace(exception, true) : new StackTrace(true)
        };
        
        if (!executionHistory.ContainsKey(node.NodeId))
        {
            executionHistory[node.NodeId] = new List<NodeExecutionInfo>();
        }
        
        executionHistory[node.NodeId].Add(info);
    }
    
    /// <summary>
    /// è·å–èŠ‚ç‚¹æ‰§è¡Œå†å²
    /// </summary>
    public List<NodeExecutionInfo> GetExecutionHistory(string nodeId)
    {
        return executionHistory.ContainsKey(nodeId) ? 
            new List<NodeExecutionInfo>(executionHistory[nodeId]) : 
            new List<NodeExecutionInfo>();
    }
}
```

### 5.2 æ–­ç‚¹ç³»ç»Ÿ

```csharp
/// <summary>
/// èŠ‚ç‚¹æ–­ç‚¹ç³»ç»Ÿ
/// æ”¯æŒåœ¨èŠ‚ç‚¹æ‰§è¡Œæ—¶è®¾ç½®æ–­ç‚¹è¿›è¡Œè°ƒè¯•
/// </summary>
public class NodeBreakpointSystem
{
    private Dictionary<string, List<Breakpoint>> nodeBreakpoints;
    private bool isDebugging = false;
    private string pausedNodeId = null;
    
    /// <summary>
    /// æ–­ç‚¹ç±»å‹
    /// </summary>
    public enum BreakpointType
    {
        OnEnter,        // è¿›å…¥èŠ‚ç‚¹æ—¶
        OnExit,         // é€€å‡ºèŠ‚ç‚¹æ—¶
        OnSuccess,      // æˆåŠŸæ—¶
        OnFailure,      // å¤±è´¥æ—¶
        OnCondition     // æ»¡è¶³æ¡ä»¶æ—¶
    }
    
    /// <summary>
    /// æ–­ç‚¹å®šä¹‰
    /// </summary>
    public class Breakpoint
    {
        public string id;
        public string nodeId;
        public BreakpointType type;
        public string condition;
        public bool enabled;
        public int hitCount;
        public int ignoreCount;
        
        public bool ShouldBreak(TreeExecutionContext context)
        {
            if (!enabled) return false;
            
            hitCount++;
            
            if (hitCount <= ignoreCount) return false;
            
            if (!string.IsNullOrEmpty(condition))
            {
                return EvaluateCondition(condition, context);
            }
            
            return true;
        }
        
        private bool EvaluateCondition(string condition, TreeExecutionContext context)
        {
            // å®ç°æ¡ä»¶è¡¨è¾¾å¼æ±‚å€¼
            // å¯ä»¥ä½¿ç”¨ç®€å•çš„è¡¨è¾¾å¼è§£æå™¨æˆ–é›†æˆç¬¬ä¸‰æ–¹åº“
            return true; // ç®€åŒ–å®ç°
        }
    }
    
    /// <summary>
    /// æ·»åŠ æ–­ç‚¹
    /// </summary>
    public void AddBreakpoint(string nodeId, BreakpointType type, string condition = null)
    {
        var breakpoint = new Breakpoint
        {
            id = System.Guid.NewGuid().ToString(),
            nodeId = nodeId,
            type = type,
            condition = condition,
            enabled = true
        };
        
        if (!nodeBreakpoints.ContainsKey(nodeId))
        {
            nodeBreakpoints[nodeId] = new List<Breakpoint>();
        }
        
        nodeBreakpoints[nodeId].Add(breakpoint);
    }
    
    /// <summary>
    /// æ£€æŸ¥æ˜¯å¦åº”è¯¥åœ¨æ­¤å¤„æ–­ç‚¹
    /// </summary>
    public bool ShouldBreakAt(string nodeId, BreakpointType type, TreeExecutionContext context)
    {
        if (!isDebugging || !nodeBreakpoints.ContainsKey(nodeId))
        {
            return false;
        }
        
        var breakpoints = nodeBreakpoints[nodeId];
        
        foreach (var breakpoint in breakpoints)
        {
            if (breakpoint.type == type && breakpoint.ShouldBreak(context))
            {
                pausedNodeId = nodeId;
                return true;
            }
        }
        
        return false;
    }
    
    /// <summary>
    /// ç»§ç»­æ‰§è¡Œ
    /// </summary>
    public void Continue()
    {
        pausedNodeId = null;
    }
    
    /// <summary>
    /// å•æ­¥æ‰§è¡Œ
    /// </summary>
    public void StepOver()
    {
        // å®ç°å•æ­¥æ‰§è¡Œé€»è¾‘
        Continue();
    }
}
```

---

## ğŸ¯ 6. æ€»ç»“

æœ¬èŠ‚ç‚¹è®¾è®¡è§„èŒƒä¸ºè¡Œä¸ºæ ‘æ–°æ‰‹å¼•å¯¼ç³»ç»Ÿæä¾›äº†å®Œæ•´çš„èŠ‚ç‚¹ä½“ç³»ï¼ŒåŒ…æ‹¬ï¼š

### 6.1 è®¾è®¡ç‰¹ç‚¹

1. **å®Œæ•´çš„èŠ‚ç‚¹åˆ†ç±»**ï¼šæ§åˆ¶ã€æ¡ä»¶ã€åŠ¨ä½œã€è£…é¥°å››å¤§ç±»èŠ‚ç‚¹
2. **çµæ´»çš„å‚æ•°ç³»ç»Ÿ**ï¼šæ”¯æŒç±»å‹æ£€æŸ¥å’Œçº¦æŸéªŒè¯
3. **ä¸°å¯Œçš„å¯è§†åŒ–**ï¼šçŠ¶æ€æ˜¾ç¤ºå’Œè°ƒè¯•æ”¯æŒ
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šå¯¹è±¡æ± å’Œæ‰§è¡Œç›‘æ§
5. **è°ƒè¯•å‹å¥½**ï¼šæ–­ç‚¹ç³»ç»Ÿå’Œæ‰§è¡Œå†å²

### 6.2 æ‰©å±•æ€§

1. **è‡ªå®šä¹‰èŠ‚ç‚¹**ï¼šåŸºäºåŸºç±»çš„æ‰©å±•æ¡†æ¶
2. **å‚æ•°é…ç½®**ï¼šçµæ´»çš„å‚æ•°å®šä¹‰å’ŒéªŒè¯
3. **è§†è§‰å®šåˆ¶**ï¼šå¯é…ç½®çš„èŠ‚ç‚¹å¤–è§‚
4. **æ€§èƒ½ç›‘æ§**ï¼šå®æ—¶çš„æ€§èƒ½åˆ†æ
5. **è°ƒè¯•æ”¯æŒ**ï¼šå®Œå–„çš„è°ƒè¯•å·¥å…·

### 6.3 æœ€ä½³å®è·µ

1. **å•ä¸€èŒè´£**ï¼šæ¯ä¸ªèŠ‚ç‚¹åªè´Ÿè´£ä¸€ä¸ªæ˜ç¡®çš„åŠŸèƒ½
2. **çŠ¶æ€ç®¡ç†**ï¼šæ­£ç¡®å¤„ç†èŠ‚ç‚¹çš„ç”Ÿå‘½å‘¨æœŸ
3. **é”™è¯¯å¤„ç†**ï¼šä¼˜é›…åœ°å¤„ç†å¼‚å¸¸æƒ…å†µ
4. **æ€§èƒ½è€ƒè™‘**ï¼šé¿å…åœ¨Executeæ–¹æ³•ä¸­è¿›è¡Œé‡å¤è®¡ç®—
5. **è°ƒè¯•æ”¯æŒ**ï¼šæä¾›å……åˆ†çš„è°ƒè¯•ä¿¡æ¯

è¿™å¥—èŠ‚ç‚¹è®¾è®¡è§„èŒƒä¸ºå¼€å‘è€…æä¾›äº†æ„å»ºå¤æ‚å¼•å¯¼é€»è¾‘çš„å¼ºå¤§å·¥å…·ï¼ŒåŒæ—¶ä¿æŒäº†è‰¯å¥½çš„æ€§èƒ½å’Œå¯ç»´æŠ¤æ€§ã€‚