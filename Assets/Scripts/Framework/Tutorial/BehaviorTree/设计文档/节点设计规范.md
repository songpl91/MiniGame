# 行为树节点设计规范

## 📋 1. 节点分类体系

### 1.1 控制节点 (Control Nodes)

控制节点负责管理子节点的执行流程和逻辑。

#### 1.1.1 序列节点 (Sequence)
```csharp
/// <summary>
/// 序列节点 - 按顺序执行所有子节点
/// 只有当所有子节点都返回Success时才返回Success
/// 任何一个子节点返回Failure时立即返回Failure
/// </summary>
public class SequenceNode : ControlNode
{
    private int currentChildIndex = 0;
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        while (currentChildIndex < Children.Count)
        {
            var child = Children[currentChildIndex];
            var status = child.Execute(context);
            
            switch (status)
            {
                case NodeStatus.Success:
                    currentChildIndex++;
                    continue;
                case NodeStatus.Failure:
                    Reset();
                    return NodeStatus.Failure;
                case NodeStatus.Running:
                    return NodeStatus.Running;
            }
        }
        
        Reset();
        return NodeStatus.Success;
    }
}
```

#### 1.1.2 选择节点 (Selector)
```csharp
/// <summary>
/// 选择节点 - 按顺序尝试执行子节点
/// 任何一个子节点返回Success时立即返回Success
/// 只有当所有子节点都返回Failure时才返回Failure
/// </summary>
public class SelectorNode : ControlNode
{
    private int currentChildIndex = 0;
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        while (currentChildIndex < Children.Count)
        {
            var child = Children[currentChildIndex];
            var status = child.Execute(context);
            
            switch (status)
            {
                case NodeStatus.Success:
                    Reset();
                    return NodeStatus.Success;
                case NodeStatus.Failure:
                    currentChildIndex++;
                    continue;
                case NodeStatus.Running:
                    return NodeStatus.Running;
            }
        }
        
        Reset();
        return NodeStatus.Failure;
    }
}
```

#### 1.1.3 并行节点 (Parallel)
```csharp
/// <summary>
/// 并行节点 - 同时执行所有子节点
/// 根据成功/失败策略决定返回状态
/// </summary>
public class ParallelNode : ControlNode
{
    [SerializeField] private ParallelPolicy successPolicy = ParallelPolicy.All;
    [SerializeField] private ParallelPolicy failurePolicy = ParallelPolicy.Any;
    
    private Dictionary<BehaviorTreeNode, NodeStatus> childStatuses;
    
    public enum ParallelPolicy
    {
        Any,    // 任意一个满足条件
        All     // 全部满足条件
    }
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        if (childStatuses == null)
        {
            childStatuses = new Dictionary<BehaviorTreeNode, NodeStatus>();
        }
        
        int successCount = 0;
        int failureCount = 0;
        int runningCount = 0;
        
        foreach (var child in Children)
        {
            if (!childStatuses.ContainsKey(child) || 
                childStatuses[child] == NodeStatus.Running)
            {
                var status = child.Execute(context);
                childStatuses[child] = status;
            }
            
            switch (childStatuses[child])
            {
                case NodeStatus.Success:
                    successCount++;
                    break;
                case NodeStatus.Failure:
                    failureCount++;
                    break;
                case NodeStatus.Running:
                    runningCount++;
                    break;
            }
        }
        
        // 检查失败条件
        if (failurePolicy == ParallelPolicy.Any && failureCount > 0)
        {
            Reset();
            return NodeStatus.Failure;
        }
        
        if (failurePolicy == ParallelPolicy.All && failureCount == Children.Count)
        {
            Reset();
            return NodeStatus.Failure;
        }
        
        // 检查成功条件
        if (successPolicy == ParallelPolicy.Any && successCount > 0)
        {
            Reset();
            return NodeStatus.Success;
        }
        
        if (successPolicy == ParallelPolicy.All && successCount == Children.Count)
        {
            Reset();
            return NodeStatus.Success;
        }
        
        return NodeStatus.Running;
    }
}
```

### 1.2 条件节点 (Condition Nodes)

条件节点用于检查游戏状态、玩家数据等条件。

#### 1.2.1 游戏状态条件
```csharp
/// <summary>
/// 游戏状态条件节点
/// 检查指定的游戏状态是否满足条件
/// </summary>
public class GameStateConditionNode : ConditionNode
{
    [SerializeField] private string stateName;
    [SerializeField] private object expectedValue;
    [SerializeField] private ComparisonOperator comparisonOperator = ComparisonOperator.Equal;
    
    public enum ComparisonOperator
    {
        Equal,              // 等于
        NotEqual,           // 不等于
        GreaterThan,        // 大于
        GreaterThanOrEqual, // 大于等于
        LessThan,           // 小于
        LessThanOrEqual,    // 小于等于
        Contains,           // 包含
        NotContains         // 不包含
    }
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        var gameData = context.GameDataProvider;
        var currentValue = gameData.GetGameState(stateName);
        
        bool conditionMet = EvaluateCondition(currentValue, expectedValue, comparisonOperator);
        
        return conditionMet ? NodeStatus.Success : NodeStatus.Failure;
    }
    
    private bool EvaluateCondition(object current, object expected, ComparisonOperator op)
    {
        // 实现各种比较逻辑
        switch (op)
        {
            case ComparisonOperator.Equal:
                return Equals(current, expected);
            case ComparisonOperator.NotEqual:
                return !Equals(current, expected);
            // ... 其他比较操作
            default:
                return false;
        }
    }
}
```

#### 1.2.2 玩家数据条件
```csharp
/// <summary>
/// 玩家数据条件节点
/// 检查玩家的等级、金币、道具等数据
/// </summary>
public class PlayerDataConditionNode : ConditionNode
{
    [SerializeField] private PlayerDataType dataType;
    [SerializeField] private string dataKey;
    [SerializeField] private object expectedValue;
    [SerializeField] private ComparisonOperator comparisonOperator;
    
    public enum PlayerDataType
    {
        Level,          // 等级
        Experience,     // 经验
        Currency,       // 货币
        Item,           // 道具
        Achievement,    // 成就
        Custom          // 自定义数据
    }
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        var playerData = context.GameDataProvider.GetPlayerData();
        object currentValue = null;
        
        switch (dataType)
        {
            case PlayerDataType.Level:
                currentValue = playerData.Level;
                break;
            case PlayerDataType.Currency:
                currentValue = playerData.GetCurrency(dataKey);
                break;
            case PlayerDataType.Item:
                currentValue = playerData.GetItemCount(dataKey);
                break;
            // ... 其他数据类型
        }
        
        bool conditionMet = EvaluateCondition(currentValue, expectedValue, comparisonOperator);
        return conditionMet ? NodeStatus.Success : NodeStatus.Failure;
    }
}
```

#### 1.2.3 UI状态条件
```csharp
/// <summary>
/// UI状态条件节点
/// 检查UI元素的状态（是否显示、是否可交互等）
/// </summary>
public class UIStateConditionNode : ConditionNode
{
    [SerializeField] private string uiPath;
    [SerializeField] private UIStateType stateType;
    [SerializeField] private bool expectedState;
    
    public enum UIStateType
    {
        Visible,        // 是否可见
        Active,         // 是否激活
        Interactable,   // 是否可交互
        Exists          // 是否存在
    }
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        var uiElement = FindUIElement(uiPath);
        if (uiElement == null)
        {
            return stateType == UIStateType.Exists && !expectedState ? 
                NodeStatus.Success : NodeStatus.Failure;
        }
        
        bool currentState = false;
        switch (stateType)
        {
            case UIStateType.Visible:
                currentState = uiElement.gameObject.activeInHierarchy;
                break;
            case UIStateType.Active:
                currentState = uiElement.gameObject.activeSelf;
                break;
            case UIStateType.Interactable:
                var selectable = uiElement.GetComponent<Selectable>();
                currentState = selectable != null && selectable.interactable;
                break;
            case UIStateType.Exists:
                currentState = true;
                break;
        }
        
        return currentState == expectedState ? NodeStatus.Success : NodeStatus.Failure;
    }
}
```

### 1.3 动作节点 (Action Nodes)

动作节点执行具体的引导操作。

#### 1.3.1 显示消息动作
```csharp
/// <summary>
/// 显示消息动作节点
/// 在屏幕上显示引导消息
/// </summary>
public class ShowMessageActionNode : ActionNode
{
    [SerializeField] private string message;
    [SerializeField] private string localizationKey;
    [SerializeField] private float duration = 3f;
    [SerializeField] private MessagePosition position = MessagePosition.Center;
    [SerializeField] private MessageStyle style = MessageStyle.Bubble;
    [SerializeField] private bool waitForConfirm = false;
    
    public enum MessagePosition
    {
        Top, Center, Bottom, Custom
    }
    
    public enum MessageStyle
    {
        Bubble, Toast, Dialog, Overlay
    }
    
    private bool isShowing = false;
    private float showStartTime;
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        if (!isShowing)
        {
            StartShowMessage(context);
            isShowing = true;
            showStartTime = Time.time;
        }
        
        // 检查是否完成
        if (waitForConfirm)
        {
            return CheckUserConfirmation() ? NodeStatus.Success : NodeStatus.Running;
        }
        else
        {
            return Time.time - showStartTime >= duration ? NodeStatus.Success : NodeStatus.Running;
        }
    }
    
    private void StartShowMessage(TreeExecutionContext context)
    {
        var displayText = GetLocalizedMessage(context);
        var messageUI = context.UIManager.GetMessageUI();
        
        messageUI.ShowMessage(displayText, position, style, duration);
        
        // 记录分析数据
        context.Analytics.TrackEvent("tutorial_message_shown", new Dictionary<string, object>
        {
            ["message_key"] = localizationKey,
            ["position"] = position.ToString(),
            ["style"] = style.ToString()
        });
    }
    
    private string GetLocalizedMessage(TreeExecutionContext context)
    {
        if (!string.IsNullOrEmpty(localizationKey))
        {
            return context.LocalizationManager.GetText(localizationKey);
        }
        return message;
    }
}
```

#### 1.3.2 高亮UI动作
```csharp
/// <summary>
/// 高亮UI动作节点
/// 高亮显示指定的UI元素
/// </summary>
public class HighlightUIActionNode : ActionNode
{
    [SerializeField] private string targetPath;
    [SerializeField] private string targetTag;
    [SerializeField] private HighlightType highlightType = HighlightType.Glow;
    [SerializeField] private Color highlightColor = Color.yellow;
    [SerializeField] private AnimationType animationType = AnimationType.Pulse;
    [SerializeField] private float intensity = 1f;
    [SerializeField] private float duration = -1f; // -1表示持续到手动停止
    
    public enum HighlightType
    {
        Glow,           // 发光效果
        Outline,        // 轮廓线
        Mask,           // 遮罩高亮
        Arrow,          // 箭头指向
        Frame           // 边框高亮
    }
    
    public enum AnimationType
    {
        None,           // 无动画
        Pulse,          // 脉冲
        Blink,          // 闪烁
        Shake,          // 震动
        Scale,          // 缩放
        Rotate          // 旋转
    }
    
    private GameObject highlightTarget;
    private HighlightEffect highlightEffect;
    private bool isHighlighting = false;
    private float highlightStartTime;
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        if (!isHighlighting)
        {
            StartHighlight(context);
            isHighlighting = true;
            highlightStartTime = Time.time;
        }
        
        // 检查是否需要停止高亮
        if (duration > 0 && Time.time - highlightStartTime >= duration)
        {
            StopHighlight();
            return NodeStatus.Success;
        }
        
        return duration > 0 ? NodeStatus.Running : NodeStatus.Success;
    }
    
    private void StartHighlight(TreeExecutionContext context)
    {
        highlightTarget = FindTargetUI(targetPath, targetTag);
        if (highlightTarget == null)
        {
            Debug.LogWarning($"找不到高亮目标: {targetPath}");
            return;
        }
        
        highlightEffect = CreateHighlightEffect(highlightTarget);
        highlightEffect.StartHighlight(highlightType, highlightColor, animationType, intensity);
        
        // 记录分析数据
        context.Analytics.TrackEvent("tutorial_highlight_started", new Dictionary<string, object>
        {
            ["target_path"] = targetPath,
            ["highlight_type"] = highlightType.ToString(),
            ["animation_type"] = animationType.ToString()
        });
    }
    
    private void StopHighlight()
    {
        if (highlightEffect != null)
        {
            highlightEffect.StopHighlight();
            highlightEffect = null;
        }
        isHighlighting = false;
    }
}
```

#### 1.3.3 等待点击动作
```csharp
/// <summary>
/// 等待点击动作节点
/// 等待用户点击指定的UI元素
/// </summary>
public class WaitForClickActionNode : ActionNode
{
    [SerializeField] private string targetPath;
    [SerializeField] private string targetTag;
    [SerializeField] private float timeout = 30f;
    [SerializeField] private bool allowSkip = true;
    [SerializeField] private string skipButtonText = "跳过";
    [SerializeField] private bool autoHighlight = true;
    
    private GameObject clickTarget;
    private Button targetButton;
    private bool isWaiting = false;
    private bool clickReceived = false;
    private float waitStartTime;
    private HighlightEffect autoHighlightEffect;
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        if (!isWaiting)
        {
            StartWaiting(context);
            isWaiting = true;
            waitStartTime = Time.time;
        }
        
        // 检查是否收到点击
        if (clickReceived)
        {
            StopWaiting();
            return NodeStatus.Success;
        }
        
        // 检查超时
        if (timeout > 0 && Time.time - waitStartTime >= timeout)
        {
            StopWaiting();
            return NodeStatus.Failure;
        }
        
        return NodeStatus.Running;
    }
    
    private void StartWaiting(TreeExecutionContext context)
    {
        clickTarget = FindTargetUI(targetPath, targetTag);
        if (clickTarget == null)
        {
            Debug.LogWarning($"找不到点击目标: {targetPath}");
            return;
        }
        
        targetButton = clickTarget.GetComponent<Button>();
        if (targetButton != null)
        {
            targetButton.onClick.AddListener(OnTargetClicked);
        }
        else
        {
            // 添加通用点击检测
            var clickDetector = clickTarget.GetComponent<ClickDetector>();
            if (clickDetector == null)
            {
                clickDetector = clickTarget.AddComponent<ClickDetector>();
            }
            clickDetector.OnClicked += OnTargetClicked;
        }
        
        // 自动高亮
        if (autoHighlight)
        {
            autoHighlightEffect = CreateHighlightEffect(clickTarget);
            autoHighlightEffect.StartHighlight(HighlightType.Glow, Color.yellow, AnimationType.Pulse, 1f);
        }
        
        // 显示跳过按钮
        if (allowSkip)
        {
            context.UIManager.ShowSkipButton(skipButtonText, OnSkipClicked);
        }
        
        // 记录分析数据
        context.Analytics.TrackEvent("tutorial_wait_click_started", new Dictionary<string, object>
        {
            ["target_path"] = targetPath,
            ["timeout"] = timeout,
            ["allow_skip"] = allowSkip
        });
    }
    
    private void OnTargetClicked()
    {
        clickReceived = true;
        
        // 记录用户行为
        var context = GetCurrentContext();
        context.Analytics.TrackEvent("tutorial_target_clicked", new Dictionary<string, object>
        {
            ["target_path"] = targetPath,
            ["wait_time"] = Time.time - waitStartTime
        });
    }
    
    private void OnSkipClicked()
    {
        clickReceived = true;
        
        // 记录跳过行为
        var context = GetCurrentContext();
        context.Analytics.TrackEvent("tutorial_step_skipped", new Dictionary<string, object>
        {
            ["target_path"] = targetPath,
            ["wait_time"] = Time.time - waitStartTime
        });
    }
    
    private void StopWaiting()
    {
        if (targetButton != null)
        {
            targetButton.onClick.RemoveListener(OnTargetClicked);
        }
        
        if (autoHighlightEffect != null)
        {
            autoHighlightEffect.StopHighlight();
            autoHighlightEffect = null;
        }
        
        var context = GetCurrentContext();
        context.UIManager.HideSkipButton();
        
        isWaiting = false;
        clickReceived = false;
    }
}
```

### 1.4 装饰节点 (Decorator Nodes)

装饰节点修改子节点的行为。

#### 1.4.1 重复装饰器
```csharp
/// <summary>
/// 重复装饰器节点
/// 重复执行子节点指定次数或直到满足条件
/// </summary>
public class RepeatDecoratorNode : DecoratorNode
{
    [SerializeField] private RepeatType repeatType = RepeatType.Count;
    [SerializeField] private int repeatCount = 1;
    [SerializeField] private float repeatInterval = 0f;
    [SerializeField] private bool resetChildOnRepeat = true;
    
    public enum RepeatType
    {
        Count,          // 重复指定次数
        UntilSuccess,   // 重复直到成功
        UntilFailure,   // 重复直到失败
        Forever         // 永远重复
    }
    
    private int currentRepeatCount = 0;
    private float lastExecutionTime = 0f;
    private NodeStatus lastChildStatus = NodeStatus.Running;
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        // 检查重复间隔
        if (repeatInterval > 0 && Time.time - lastExecutionTime < repeatInterval)
        {
            return NodeStatus.Running;
        }
        
        // 执行子节点
        if (Child != null)
        {
            var childStatus = Child.Execute(context);
            
            // 子节点还在运行中
            if (childStatus == NodeStatus.Running)
            {
                return NodeStatus.Running;
            }
            
            lastChildStatus = childStatus;
            lastExecutionTime = Time.time;
            
            // 检查是否需要继续重复
            if (ShouldContinueRepeat(childStatus))
            {
                currentRepeatCount++;
                
                if (resetChildOnRepeat)
                {
                    Child.OnReset();
                }
                
                return NodeStatus.Running;
            }
            else
            {
                Reset();
                return childStatus;
            }
        }
        
        return NodeStatus.Failure;
    }
    
    private bool ShouldContinueRepeat(NodeStatus childStatus)
    {
        switch (repeatType)
        {
            case RepeatType.Count:
                return currentRepeatCount < repeatCount;
            case RepeatType.UntilSuccess:
                return childStatus != NodeStatus.Success;
            case RepeatType.UntilFailure:
                return childStatus != NodeStatus.Failure;
            case RepeatType.Forever:
                return true;
            default:
                return false;
        }
    }
    
    public override void OnReset()
    {
        base.OnReset();
        currentRepeatCount = 0;
        lastExecutionTime = 0f;
        lastChildStatus = NodeStatus.Running;
    }
}
```

#### 1.4.2 延迟装饰器
```csharp
/// <summary>
/// 延迟装饰器节点
/// 延迟指定时间后执行子节点
/// </summary>
public class DelayDecoratorNode : DecoratorNode
{
    [SerializeField] private float delayTime = 1f;
    [SerializeField] private bool randomDelay = false;
    [SerializeField] private float minDelay = 0.5f;
    [SerializeField] private float maxDelay = 2f;
    
    private bool isDelaying = false;
    private float delayStartTime;
    private float actualDelayTime;
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        if (!isDelaying)
        {
            StartDelay();
            isDelaying = true;
            delayStartTime = Time.time;
        }
        
        // 检查延迟是否结束
        if (Time.time - delayStartTime >= actualDelayTime)
        {
            // 延迟结束，执行子节点
            if (Child != null)
            {
                var childStatus = Child.Execute(context);
                
                if (childStatus != NodeStatus.Running)
                {
                    Reset();
                }
                
                return childStatus;
            }
            else
            {
                Reset();
                return NodeStatus.Success;
            }
        }
        
        return NodeStatus.Running;
    }
    
    private void StartDelay()
    {
        if (randomDelay)
        {
            actualDelayTime = UnityEngine.Random.Range(minDelay, maxDelay);
        }
        else
        {
            actualDelayTime = delayTime;
        }
    }
    
    public override void OnReset()
    {
        base.OnReset();
        isDelaying = false;
        delayStartTime = 0f;
        actualDelayTime = 0f;
    }
}
```

#### 1.4.3 条件装饰器
```csharp
/// <summary>
/// 条件装饰器节点
/// 只有当条件满足时才执行子节点
/// </summary>
public class ConditionalDecoratorNode : DecoratorNode
{
    [SerializeField] private string conditionKey;
    [SerializeField] private object expectedValue;
    [SerializeField] private ComparisonOperator comparisonOperator = ComparisonOperator.Equal;
    [SerializeField] private bool checkEveryTick = false;
    
    private bool conditionChecked = false;
    private bool conditionMet = false;
    
    public override NodeStatus Execute(TreeExecutionContext context)
    {
        // 检查条件
        if (!conditionChecked || checkEveryTick)
        {
            conditionMet = CheckCondition(context);
            conditionChecked = true;
        }
        
        if (!conditionMet)
        {
            return NodeStatus.Failure;
        }
        
        // 条件满足，执行子节点
        if (Child != null)
        {
            var childStatus = Child.Execute(context);
            
            if (childStatus != NodeStatus.Running)
            {
                Reset();
            }
            
            return childStatus;
        }
        
        return NodeStatus.Success;
    }
    
    private bool CheckCondition(TreeExecutionContext context)
    {
        var blackboard = context.Blackboard;
        var currentValue = blackboard.GetValue<object>(conditionKey);
        
        return EvaluateCondition(currentValue, expectedValue, comparisonOperator);
    }
    
    public override void OnReset()
    {
        base.OnReset();
        conditionChecked = false;
        conditionMet = false;
    }
}
```

## 🔧 2. 节点参数配置系统

### 2.1 参数定义框架

```csharp
/// <summary>
/// 节点参数定义
/// 定义节点可配置的参数
/// </summary>
[System.Serializable]
public class ParameterDefinition
{
    public string name;                 // 参数名称
    public string displayName;          // 显示名称
    public ParameterType type;          // 参数类型
    public object defaultValue;         // 默认值
    public bool required;               // 是否必需
    public string description;          // 参数描述
    public ParameterConstraint constraint; // 参数约束
    
    public enum ParameterType
    {
        String,
        Int,
        Float,
        Bool,
        Vector2,
        Vector3,
        Color,
        Enum,
        Object,
        Array,
        Custom
    }
}

/// <summary>
/// 参数约束
/// </summary>
[System.Serializable]
public class ParameterConstraint
{
    public object minValue;             // 最小值
    public object maxValue;             // 最大值
    public string[] allowedValues;      // 允许的值列表
    public string validationRegex;      // 验证正则表达式
    public string validationMessage;    // 验证失败消息
}
```

### 2.2 参数验证系统

```csharp
/// <summary>
/// 参数验证器
/// 验证节点参数的有效性
/// </summary>
public class ParameterValidator
{
    /// <summary>
    /// 验证结果
    /// </summary>
    public class ValidationResult
    {
        public bool IsValid { get; set; }
        public List<string> Errors { get; set; } = new List<string>();
        public List<string> Warnings { get; set; } = new List<string>();
        
        public static ValidationResult Success => new ValidationResult { IsValid = true };
        
        public static ValidationResult Failure(string error)
        {
            return new ValidationResult 
            { 
                IsValid = false, 
                Errors = new List<string> { error } 
            };
        }
    }
    
    /// <summary>
    /// 验证节点参数
    /// </summary>
    public ValidationResult ValidateParameters(BehaviorTreeNode node, NodeConfig config)
    {
        var result = new ValidationResult { IsValid = true };
        var definitions = node.GetParameterDefinitions();
        
        foreach (var definition in definitions)
        {
            var paramResult = ValidateParameter(definition, config.GetParameter(definition.name));
            
            if (!paramResult.IsValid)
            {
                result.IsValid = false;
                result.Errors.AddRange(paramResult.Errors);
            }
            
            result.Warnings.AddRange(paramResult.Warnings);
        }
        
        return result;
    }
    
    private ValidationResult ValidateParameter(ParameterDefinition definition, object value)
    {
        var result = new ValidationResult { IsValid = true };
        
        // 检查必需参数
        if (definition.required && (value == null || value.Equals(GetDefaultValue(definition.type))))
        {
            return ValidationResult.Failure($"参数 '{definition.displayName}' 是必需的");
        }
        
        if (value == null)
        {
            return result;
        }
        
        // 类型检查
        if (!IsValidType(value, definition.type))
        {
            return ValidationResult.Failure($"参数 '{definition.displayName}' 类型不匹配");
        }
        
        // 约束检查
        if (definition.constraint != null)
        {
            var constraintResult = ValidateConstraint(value, definition.constraint);
            if (!constraintResult.IsValid)
            {
                return constraintResult;
            }
        }
        
        return result;
    }
}
```

## 🎨 3. 节点可视化设计

### 3.1 节点外观配置

```csharp
/// <summary>
/// 节点视觉配置
/// 定义节点在编辑器中的外观
/// </summary>
[System.Serializable]
public class NodeVisualConfig
{
    [Header("基本外观")]
    public Color nodeColor = Color.white;
    public string iconPath = "";
    public Vector2 nodeSize = new Vector2(150, 100);
    
    [Header("文本显示")]
    public string displayName = "";
    public string description = "";
    public Color textColor = Color.black;
    public int fontSize = 12;
    
    [Header("连接点")]
    public bool hasInputPort = true;
    public bool hasOutputPort = true;
    public int maxInputConnections = 1;
    public int maxOutputConnections = -1; // -1表示无限制
    
    [Header("动画效果")]
    public bool enableHoverEffect = true;
    public bool enableSelectionEffect = true;
    public AnimationCurve scaleAnimation = AnimationCurve.EaseInOut(0, 1, 1, 1.1f);
}
```

### 3.2 节点状态可视化

```csharp
/// <summary>
/// 节点状态可视化
/// 在编辑器中显示节点的运行状态
/// </summary>
public class NodeStatusVisualizer
{
    private Dictionary<NodeStatus, NodeStatusStyle> statusStyles;
    
    [System.Serializable]
    public class NodeStatusStyle
    {
        public Color borderColor;
        public Color backgroundColor;
        public float borderWidth;
        public bool enablePulse;
        public float pulseSpeed;
        public string statusIcon;
    }
    
    public void InitializeStyles()
    {
        statusStyles = new Dictionary<NodeStatus, NodeStatusStyle>
        {
            [NodeStatus.Success] = new NodeStatusStyle
            {
                borderColor = Color.green,
                backgroundColor = new Color(0, 1, 0, 0.2f),
                borderWidth = 3f,
                enablePulse = false,
                statusIcon = "✓"
            },
            [NodeStatus.Failure] = new NodeStatusStyle
            {
                borderColor = Color.red,
                backgroundColor = new Color(1, 0, 0, 0.2f),
                borderWidth = 3f,
                enablePulse = false,
                statusIcon = "✗"
            },
            [NodeStatus.Running] = new NodeStatusStyle
            {
                borderColor = Color.yellow,
                backgroundColor = new Color(1, 1, 0, 0.2f),
                borderWidth = 2f,
                enablePulse = true,
                pulseSpeed = 2f,
                statusIcon = "▶"
            }
        };
    }
    
    public void UpdateNodeVisual(NodeView nodeView, NodeStatus status)
    {
        if (statusStyles.TryGetValue(status, out var style))
        {
            nodeView.SetBorderColor(style.borderColor);
            nodeView.SetBackgroundColor(style.backgroundColor);
            nodeView.SetBorderWidth(style.borderWidth);
            nodeView.SetStatusIcon(style.statusIcon);
            
            if (style.enablePulse)
            {
                nodeView.StartPulseAnimation(style.pulseSpeed);
            }
            else
            {
                nodeView.StopPulseAnimation();
            }
        }
    }
}
```

## 📊 4. 节点性能优化

### 4.1 节点对象池

```csharp
/// <summary>
/// 节点对象池
/// 管理节点实例的创建和回收
/// </summary>
public class NodeObjectPool
{
    private Dictionary<System.Type, Queue<BehaviorTreeNode>> pools;
    private Dictionary<System.Type, int> poolSizes;
    private int defaultPoolSize = 10;
    private int maxPoolSize = 100;
    
    public T GetNode<T>() where T : BehaviorTreeNode, new()
    {
        var type = typeof(T);
        
        if (!pools.ContainsKey(type))
        {
            pools[type] = new Queue<BehaviorTreeNode>();
            poolSizes[type] = 0;
        }
        
        var pool = pools[type];
        
        if (pool.Count > 0)
        {
            var node = pool.Dequeue() as T;
            node.OnReset();
            return node;
        }
        else
        {
            return new T();
        }
    }
    
    public void ReturnNode<T>(T node) where T : BehaviorTreeNode
    {
        if (node == null) return;
        
        var type = typeof(T);
        
        if (!pools.ContainsKey(type))
        {
            pools[type] = new Queue<BehaviorTreeNode>();
            poolSizes[type] = 0;
        }
        
        var pool = pools[type];
        
        if (pool.Count < maxPoolSize)
        {
            node.OnReset();
            pool.Enqueue(node);
        }
    }
    
    public void PrewarmPool<T>(int count) where T : BehaviorTreeNode, new()
    {
        for (int i = 0; i < count; i++)
        {
            var node = new T();
            ReturnNode(node);
        }
    }
}
```

### 4.2 节点执行优化

```csharp
/// <summary>
/// 节点执行优化器
/// 优化节点的执行性能
/// </summary>
public class NodeExecutionOptimizer
{
    private Dictionary<string, float> nodeExecutionTimes;
    private Dictionary<string, int> nodeExecutionCounts;
    private float performanceThreshold = 16.67f; // 60FPS阈值
    
    /// <summary>
    /// 监控节点执行性能
    /// </summary>
    public void MonitorNodeExecution(BehaviorTreeNode node, System.Action nodeExecution)
    {
        var startTime = Time.realtimeSinceStartup;
        
        nodeExecution.Invoke();
        
        var executionTime = (Time.realtimeSinceStartup - startTime) * 1000f; // 转换为毫秒
        
        RecordExecutionTime(node.NodeId, executionTime);
        
        if (executionTime > performanceThreshold)
        {
            Debug.LogWarning($"节点 {node.NodeId} 执行时间过长: {executionTime:F2}ms");
        }
    }
    
    private void RecordExecutionTime(string nodeId, float executionTime)
    {
        if (!nodeExecutionTimes.ContainsKey(nodeId))
        {
            nodeExecutionTimes[nodeId] = 0f;
            nodeExecutionCounts[nodeId] = 0;
        }
        
        nodeExecutionTimes[nodeId] += executionTime;
        nodeExecutionCounts[nodeId]++;
    }
    
    /// <summary>
    /// 获取节点平均执行时间
    /// </summary>
    public float GetAverageExecutionTime(string nodeId)
    {
        if (nodeExecutionTimes.ContainsKey(nodeId) && nodeExecutionCounts[nodeId] > 0)
        {
            return nodeExecutionTimes[nodeId] / nodeExecutionCounts[nodeId];
        }
        return 0f;
    }
    
    /// <summary>
    /// 生成性能报告
    /// </summary>
    public PerformanceReport GeneratePerformanceReport()
    {
        var report = new PerformanceReport();
        
        foreach (var kvp in nodeExecutionTimes)
        {
            var nodeId = kvp.Key;
            var totalTime = kvp.Value;
            var count = nodeExecutionCounts[nodeId];
            var averageTime = totalTime / count;
            
            report.NodePerformances.Add(new NodePerformanceData
            {
                NodeId = nodeId,
                TotalExecutionTime = totalTime,
                ExecutionCount = count,
                AverageExecutionTime = averageTime,
                IsPerformanceCritical = averageTime > performanceThreshold
            });
        }
        
        return report;
    }
}

/// <summary>
/// 性能报告
/// </summary>
public class PerformanceReport
{
    public List<NodePerformanceData> NodePerformances { get; set; } = new List<NodePerformanceData>();
    public float TotalExecutionTime => NodePerformances.Sum(p => p.TotalExecutionTime);
    public int TotalExecutionCount => NodePerformances.Sum(p => p.ExecutionCount);
    public float AverageExecutionTime => TotalExecutionTime / TotalExecutionCount;
}

/// <summary>
/// 节点性能数据
/// </summary>
public class NodePerformanceData
{
    public string NodeId { get; set; }
    public float TotalExecutionTime { get; set; }
    public int ExecutionCount { get; set; }
    public float AverageExecutionTime { get; set; }
    public bool IsPerformanceCritical { get; set; }
}
```

## 🔍 5. 节点调试支持

### 5.1 调试信息收集

```csharp
/// <summary>
/// 节点调试信息收集器
/// 收集节点执行过程中的调试信息
/// </summary>
public class NodeDebugInfoCollector
{
    private Dictionary<string, List<NodeExecutionInfo>> executionHistory;
    private int maxHistorySize = 1000;
    
    /// <summary>
    /// 节点执行信息
    /// </summary>
    public class NodeExecutionInfo
    {
        public string nodeId;
        public string nodeType;
        public float timestamp;
        public NodeStatus inputStatus;
        public NodeStatus outputStatus;
        public float executionTime;
        public Dictionary<string, object> parameters;
        public Dictionary<string, object> blackboardSnapshot;
        public string errorMessage;
        public StackTrace stackTrace;
    }
    
    /// <summary>
    /// 记录节点执行信息
    /// </summary>
    public void RecordExecution(BehaviorTreeNode node, NodeStatus inputStatus, 
        NodeStatus outputStatus, float executionTime, TreeExecutionContext context)
    {
        var info = new NodeExecutionInfo
        {
            nodeId = node.NodeId,
            nodeType = node.GetType().Name,
            timestamp = Time.time,
            inputStatus = inputStatus,
            outputStatus = outputStatus,
            executionTime = executionTime,
            parameters = GetNodeParameters(node),
            blackboardSnapshot = GetBlackboardSnapshot(context.Blackboard)
        };
        
        if (!executionHistory.ContainsKey(node.NodeId))
        {
            executionHistory[node.NodeId] = new List<NodeExecutionInfo>();
        }
        
        var history = executionHistory[node.NodeId];
        history.Add(info);
        
        // 限制历史记录大小
        if (history.Count > maxHistorySize)
        {
            history.RemoveAt(0);
        }
    }
    
    /// <summary>
    /// 记录节点错误
    /// </summary>
    public void RecordError(BehaviorTreeNode node, string errorMessage, System.Exception exception = null)
    {
        var info = new NodeExecutionInfo
        {
            nodeId = node.NodeId,
            nodeType = node.GetType().Name,
            timestamp = Time.time,
            errorMessage = errorMessage,
            stackTrace = exception != null ? new StackTrace(exception, true) : new StackTrace(true)
        };
        
        if (!executionHistory.ContainsKey(node.NodeId))
        {
            executionHistory[node.NodeId] = new List<NodeExecutionInfo>();
        }
        
        executionHistory[node.NodeId].Add(info);
    }
    
    /// <summary>
    /// 获取节点执行历史
    /// </summary>
    public List<NodeExecutionInfo> GetExecutionHistory(string nodeId)
    {
        return executionHistory.ContainsKey(nodeId) ? 
            new List<NodeExecutionInfo>(executionHistory[nodeId]) : 
            new List<NodeExecutionInfo>();
    }
}
```

### 5.2 断点系统

```csharp
/// <summary>
/// 节点断点系统
/// 支持在节点执行时设置断点进行调试
/// </summary>
public class NodeBreakpointSystem
{
    private Dictionary<string, List<Breakpoint>> nodeBreakpoints;
    private bool isDebugging = false;
    private string pausedNodeId = null;
    
    /// <summary>
    /// 断点类型
    /// </summary>
    public enum BreakpointType
    {
        OnEnter,        // 进入节点时
        OnExit,         // 退出节点时
        OnSuccess,      // 成功时
        OnFailure,      // 失败时
        OnCondition     // 满足条件时
    }
    
    /// <summary>
    /// 断点定义
    /// </summary>
    public class Breakpoint
    {
        public string id;
        public string nodeId;
        public BreakpointType type;
        public string condition;
        public bool enabled;
        public int hitCount;
        public int ignoreCount;
        
        public bool ShouldBreak(TreeExecutionContext context)
        {
            if (!enabled) return false;
            
            hitCount++;
            
            if (hitCount <= ignoreCount) return false;
            
            if (!string.IsNullOrEmpty(condition))
            {
                return EvaluateCondition(condition, context);
            }
            
            return true;
        }
        
        private bool EvaluateCondition(string condition, TreeExecutionContext context)
        {
            // 实现条件表达式求值
            // 可以使用简单的表达式解析器或集成第三方库
            return true; // 简化实现
        }
    }
    
    /// <summary>
    /// 添加断点
    /// </summary>
    public void AddBreakpoint(string nodeId, BreakpointType type, string condition = null)
    {
        var breakpoint = new Breakpoint
        {
            id = System.Guid.NewGuid().ToString(),
            nodeId = nodeId,
            type = type,
            condition = condition,
            enabled = true
        };
        
        if (!nodeBreakpoints.ContainsKey(nodeId))
        {
            nodeBreakpoints[nodeId] = new List<Breakpoint>();
        }
        
        nodeBreakpoints[nodeId].Add(breakpoint);
    }
    
    /// <summary>
    /// 检查是否应该在此处断点
    /// </summary>
    public bool ShouldBreakAt(string nodeId, BreakpointType type, TreeExecutionContext context)
    {
        if (!isDebugging || !nodeBreakpoints.ContainsKey(nodeId))
        {
            return false;
        }
        
        var breakpoints = nodeBreakpoints[nodeId];
        
        foreach (var breakpoint in breakpoints)
        {
            if (breakpoint.type == type && breakpoint.ShouldBreak(context))
            {
                pausedNodeId = nodeId;
                return true;
            }
        }
        
        return false;
    }
    
    /// <summary>
    /// 继续执行
    /// </summary>
    public void Continue()
    {
        pausedNodeId = null;
    }
    
    /// <summary>
    /// 单步执行
    /// </summary>
    public void StepOver()
    {
        // 实现单步执行逻辑
        Continue();
    }
}
```

---

## 🎯 6. 总结

本节点设计规范为行为树新手引导系统提供了完整的节点体系，包括：

### 6.1 设计特点

1. **完整的节点分类**：控制、条件、动作、装饰四大类节点
2. **灵活的参数系统**：支持类型检查和约束验证
3. **丰富的可视化**：状态显示和调试支持
4. **性能优化**：对象池和执行监控
5. **调试友好**：断点系统和执行历史

### 6.2 扩展性

1. **自定义节点**：基于基类的扩展框架
2. **参数配置**：灵活的参数定义和验证
3. **视觉定制**：可配置的节点外观
4. **性能监控**：实时的性能分析
5. **调试支持**：完善的调试工具

### 6.3 最佳实践

1. **单一职责**：每个节点只负责一个明确的功能
2. **状态管理**：正确处理节点的生命周期
3. **错误处理**：优雅地处理异常情况
4. **性能考虑**：避免在Execute方法中进行重复计算
5. **调试支持**：提供充分的调试信息

这套节点设计规范为开发者提供了构建复杂引导逻辑的强大工具，同时保持了良好的性能和可维护性。